// New emits a message in an infinite loop.
// It is inteited to be used with #bind directive.
// You should prefer constant references and literals over New if possible.
// New, just like constant senders, must be used with caution.
// Being infinite, it can easily lead to buffer overflow.
// New is within small group of components without inports.
#extern(new)
pub def New<T>() (res T)

#extern(new_v2)
pub def NewV2<T>(sig any) (res T)

// Del receives and discards the message.
// You should avoid using it because compiler will insert it automatically
// for every unused outport.
// Del is within small group of components without outports.
#extern(del)
pub def Del(data any) ()

// Panic immidiately terminates the program after message is received.
// It exits the process with non-zero status code and prints flowtrace to stderr.
// Panic is within small group of components without outports.
#extern(panic)
pub def Panic(data any) ()

// Struct is used to create structures.
// Inports for Struct are generated by compiler based on provided type argument
// thanks to #autoports directive. This is why it has no inports in source code.
// This is the only component that should use #autoports.
#autoports
#extern(struct_builder)
pub def Struct<T struct {}> () (res T)

// Field is used to access fields of structures.
// You prefer dot notation `-> .<field> ->` instead.
// Dot notation is a syntax sugar for Field.
#extern(field)
pub def Field<T>(data struct {}) (res T)

// Unwrap is used to extract value from Maybe type.
#extern(unwrap)
pub def Unwrap<T>(data maybe<T>) (some T, none struct{})

// Get retrieves a value from a dictionary using the provided key.
// It has two inports: 'dict' for the dictionary and 'key' for the lookup key.
// Sends result to 'res' outport, or error to 'err' if key not found.
#extern(get_dict_value)
pub def Get<T>(dict dict<T>, key T) (res T, err error)

// Pass is used to pass data through. It receives data and sends it to outport.
// E.g. when you want to trigger a constant from deferred connection
// and then use it as a sender in fan-in receiver-side:
// :start -> 99 -> pass; [pass, receiver2] -> ...
pub def Pass<T>(data T) (res T) {
    :data -> :res
}

// Sometimes component needs to receive data, perform some action and pass that
// data further. However, due to impossibility to reuse same sender twice or
// more, it leads to need for explicit locks. Deferred connections do not cover
// this case. Explicit lock make network harder to reason about.
// `Tap` is a higher-order component, that implements this logic for you.
// All you need to do, is to provide dependency node, that receives data and
// sends a signal when finishes. Signal could be of any type, so no need for
// dealing with locks manually. Handler can send error, in that case `Tap` will
// propagate it up to parent node.
pub def Tap<T>(data T) (res T, err error) {
    proxy1 Pass<T>
    proxy2 Pass<T>
    lock Lock<T>
    handler ITapHandler<T>
    ---
    :data -> [lock:data, handler]

    handler:res -> proxy1
    handler:err -> [proxy2, :err]

    [proxy1, proxy2] -> lock:sig
    lock -> :res
}

pub interface ITapHandler<T>(T) (res any, err error)
